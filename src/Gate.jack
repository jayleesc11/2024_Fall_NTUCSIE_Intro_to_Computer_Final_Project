class Gate {
    // Constants
    static int x_width;             // Width of gates
    static int y_height;            // Height of gates
    static int x_vel;               // Movement speed on screen
    static int x_interval;          // Interval between gates x1's
    static int y_upper_margin;      // Upper margin of obstacles
    static int y_obs_height;        // Height of obstacles
    static int y_gate_interval;     // Interval between gates y1's

    // Static
    static boolean output;           // Gate output

    // Fields
    field int x1;                   // x1 position on screen
    field int x1_init;              // Initial x1 position on screen
    field int x1_init_mem;          // Initial x1 position in memory
    field int y1;                   // (Initial) y1 position on screen
    field int y1_mem;               // (Initial) y1 position in memory
    field int y2;                   // (Initial) y2 position on screen
    field int mem_pos;              // Position in memory
    field int sprite_seq;           // Sprite sequence
    field int sprite_seq_init;      // Initial sprite sequence
    field int y_collision_upper;    // Collision upper bound
    field int y_collision_lower;    // Collision lower bound

    field int type;                 // Gate type {0:NULL, 1:AND, 2:NAND, 3:OR, 4:NOR, 5:XOR, 6:XNOR}
    field boolean input_rand;       // Input 2
    field boolean exists;           // Gate exists
    field boolean erased;           // Gate erased

    function void init(int margin, int obs_height) {
        let x_width = 100;
        let y_height = 50;
        let x_vel = 2;
        let y_upper_margin = margin;
        let y_obs_height = obs_height;

        let x_interval = ((512 - x_width) / 2) + x_width;                                       // 306
        let y_gate_interval = (255 - y_upper_margin - (y_obs_height * 2) - (y_height * 3)) / 6; // 10
        return;
    }

    constructor Gate new(int x_index, int y_index) {
        let x1_init = 512 + (x_interval * (x_index - 1));
        let x1 = x1_init;
        let x1_init_mem = 25;
        let y1 = y_upper_margin + y_gate_interval + ((y_height + y_obs_height + (y_gate_interval * 2)) * (y_index - 1));
        let y1_mem = y1 * 32;
        let y2 = y1 + y_height - 1;
        let mem_pos = x1_init_mem + y1_mem;
        let sprite_seq_init = 4;
        let sprite_seq = sprite_seq_init;
        let y_collision_lower = y1 - y_gate_interval;
        let y_collision_upper = y1 + y_height + y_gate_interval;
        return this;
    }

    method void reset() {
        let x1 = x1_init;
        let mem_pos = x1_init_mem + y1_mem;
        let sprite_seq = sprite_seq_init;
        let type = LCGRandom.randRange(1,6);
        let input_rand = LCGRandom.randRange(0,1);
        let exists = true;
        let erased = false;
        return;
    }

    method void rebuild() {
        do reset();
        let x1 = 512;
        return;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    
    method boolean collision(int player_x1, int player_y1, int player_x2, int player_y2, boolean player_state) {
        if (exists & (player_x1 < (x1 + x_width)) & (player_x2 > x1) & (player_y1 < y_collision_upper) & (player_y2 > y_collision_lower)) {
            do logic(player_state);
            let exists = false;
            return true;
        }
        return false;
    }

    method void logic(boolean input_stat) {
        if (type = 1) {let output = input_stat & input_rand;} else { 
        if (type = 2) {let output = ~(input_stat & input_rand);} else { 
        if (type = 3) {let output = input_stat | input_rand;} else { 
        if (type = 4) {let output = ~(input_stat | input_rand);} else { 
        if (type = 5) {let output = (input_stat & ~input_rand) | (~input_stat & input_rand);} else { 
        if (type = 6) {let output = (input_stat & input_rand) | (~input_stat & ~input_rand);} else { 
        let output = false;}}}}}}
        return;
    }

    method void tick() {
        if (x1 + 1 < -x_width) {
            do rebuild();
        } else {
            let x1 = x1 - x_vel;
            /*if (~exists & (x1 < 102)) {
                let exists = true;
            }*/
        }
        return;
    }

    method void draw() {
        do Screen.setColor(true);
        do Screen.drawRectangle(Math.min(Math.max(x1,0),511), y1, Math.min(Math.max(x1 + x_vel,0),511), y2);
        do Screen.setColor(false);
        do Screen.drawRectangle(Math.min(Math.max(x1 + x_width,0),511), y1, Math.min(Math.max(x1 + x_width + x_vel,0),511), y2);
        /*
        if (sprite_seq = 0) {
            let sprite_seq = 7;
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        } else {
        if (sprite_seq = 1) {
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        } else {
        if (sprite_seq = 2) {
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        } else {
        if (sprite_seq = 3) {
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        } else {
        if (sprite_seq = 4) {
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        } else {
        if (sprite_seq = 5) {
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        } else {
        if (sprite_seq = 6) {
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        } else {
        if (sprite_seq = 7) {
            if (type = 1) {} else {
            if (type = 2) {} else {
            if (type = 3) {} else {
            if (type = 4) {} else {
            if (type = 5) {} else {
            if (type = 6) {} }}}}}
        }}}}}}}
        let sprite_seq = sprite_seq - 1;
        */
        return;
    }

    method void update() {
        if (exists) {
            do draw();
        } else {if (~erased) {
                do Screen.setColor(false);
                do Screen.drawRectangle(Math.min(Math.max(x1,0),511), y1, Math.min(Math.max(x1 + x_width+ x_vel,0),511), y1 + y_height);
                let erased = true;
            }
        }
        do tick();
        return;
    }

    function int width() { return x_width; }
    function boolean output() { return output; }
}
